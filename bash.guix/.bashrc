# -*- sh -*-
# This file is sourced by all *interactive* bash shells on startup,
# including some apparently interactive shells such as scp and rcp
# that can't tolerate any output.  So make sure this doesn't display
# anything or bad things will happen !


# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.
if [[ $- != *i* ]]
then
    # Shell is non-interactive.  Be done now!
    return
fi

# Don't execute commands when match fails
shopt -s failglob

## inject to shell
eval "$(zoxide init bash)"
eval "$(fzf --bash)"

if ! command -v get-current-workspace-name >/dev/null
then
    get-current-workspace-name() { :; }
fi

PREV_ORG_PROMPT=""

gen_prompt() {
    local ec="$?"
    local branch="" user_prefix="" hints="" ORG_PROMPT=""
    history -a

    # kludge !!, as long as it works
    PS1=$(echo -n "$PS1" | sed 's/^\\e\[41;37;1m [0-9][0-9]* \\e\[0m\s*//')

    if command -v git >/dev/null 2>/dev/null
    then
        branch="$(git branch --show-current 2>/dev/null)"
        [[ -n "$branch" ]] &&
            branch="\e[47m\e[30m${branch:+ }${branch}${branch:+ }\e[0m"
    fi

    if [[ "$USER" != "rmnull" ]] || [[ -n "$SSH_CONNECTION" ]]
    then
        user_prefix="\e[31;1m\u\e[0m @ \e[33;1m\h\e[0m"
    else
        user_prefix=""
    fi

    if [[ -n $HOMEBREW_DEVELOPER ]]
    then
        hints+="\e[1;33müç∫\e[;0m"
    fi

    if [[ -n "$GUIX_ENVIRONMENT" ]]
    then
        local color="\e[38;5;166m" end_color="\e[0m"
        local guix_hint="${color}guix${end_color}"
        hints="[${guix_hint}]${hints:+ ${hints}}"
    fi

    ORG_PROMPT="${user_prefix}${user_prefix:+: }${branch:+${branch}}${branch:+ }${hints}\e[38;5;227m \w\e[0m\n‚à´ "

    if [[ -z $PREV_ORG_PROMPT ]]
    then
        PREV_ORG_PROMPT=$ORG_PROMPT
    fi

    # of course, this assumes other scripts don't make modifications to the
    # in the middle of PS1
    # dont overwrite prompt generated by other scripts
    # other scripts may have added additional info the prompt
    local pre_diff="" PREFIX=""
    pre_diff="$(( ${#PS1} - ${#PREV_ORG_PROMPT} ))"
    if [[ $pre_diff -gt 0 ]]
    then
        PREFIX="${PS1:0:${pre_diff}}"
    else
        PREFIX=""
    fi
    local SUFFIX="${PS1:$(( ${#PREFIX} + ${#PREV_ORG_PROMPT} ))}"

    PS1="${PREFIX}${ORG_PROMPT}${SUFFIX}"
    PREV_ORG_PROMPT=${ORG_PROMPT}

    if [[ $ec != "0" ]] ; then
        PS1="\e[41;37;1m $ec \e[0m ${PS1}"
    fi
}

if [[ -z "$PROMPT_COMMAND" ]]
then
    PROMPT_COMMAND=gen_prompt
else
    PROMPT_COMMAND="gen_prompt;${PROMPT_COMMAND}"
fi

if [[ -f ~/.bash_aliases ]]
then
    . ~/.bash_aliases
fi

srec() {
    if [[ $# -gt 0 ]]
    then
        echo -e "WARN: doesn't accept any args. Ignoring all the arguments\n\n"
    fi

    local date_format=$(date --iso-8601=minutes)
    local save_dir="${HOME}/Videos/screenrecords"
    local out="${save_dir}/srec_${date_format}"
    local out_ll="${out}.mkv"
    local out_lo="${out}.webm"
    local display=${DISPLAY:-0.0}
    mkdir -p "$save_dir"
    ffmpeg -video_size 1920x1080 -framerate 30 -f x11grab -i "$display" -c:v libx264rgb -crf 0 -preset ultrafast "${out_ll}" \
        && ffmpeg -i "$out_ll" "$out_lo" && echo "saved to $out_lo"
}
rand_sym() {
    if [[ -z "$1" ]]
    then
        return;
    fi
    local symbols=$1;
    ## restrict to 7 bytes(2 ^ 56), as bash overflows at 2 ^ 63
    local randint=$(od --output-duplicates --address-radix=n --read-bytes=7 -t u8 </dev/urandom);
    local symbol_idx=$(( randint % ${#symbols} ))
    echo "${symbols:$symbol_idx:1}"
}

genpwd() {
    local dict_file="${HOME}/af/words-nouns.txt"
    [[ -e "$dict_file" ]] || return;
    local n_words=6;
    local min_word_len=3;
    local max_word_len=10;
    local separator=$(rand_sym '+-*/=_,.~><;:| ');
    local padding_symbol=$(rand_sym '~!@#$%^&*([{+=/|');
    local padding_start_symbol=$padding_symbol;
    local padding_end_symbol=$padding_symbol;
    [[ $padding_symbol = "(" ]] && padding_end_symbol=")";
    [[ $padding_symbol = "[" ]] && padding_end_symbol="]";
    [[ $padding_symbol = "{" ]] && padding_end_symbol="}";

    awk '/^[a-zA-Z0-9]+$/ && length($0) >= '"$min_word_len"' && length($0) <= '"$max_word_len" "$dict_file" \
        | shuf --repeat --random-source=/dev/urandom -n $n_words \
        | tr '\n' "$separator" \
        | tr '[:upper:]' '[:lower:]' \
        | sed -e 's/^\(.*\).$/\1/' \
        | xargs -I _ echo "$padding_start_symbol"_"$padding_end_symbol"
}

mupdf() {
    elog=$(command mupdf "$@" 2>&1)
    local mupdf_ec=$?

    if [[ "$mupdf_ec" != "0" ]] && grep -i '^error: needs a password' <<<"$elog"
    then
        local pass=$(zenity --title="PDF Password" --password)
        command mupdf -p "$pass" "$@"
        mupdf_ec=$?
    else
        echo -e "$elog" >&2
    fi

    ## honor MuPDF exit status
    return $mupdf_ec
}

scap() {
    local save_dir="${HOME}/Pictures/scaps/"
    mkdir -p "$save_dir"
    ## one of 'window' | 'select' | 'screen'
    local shot_mode="select" shot_mode_flag="-s"
    local delay=0
    local save_as="${save_dir}/#%s-${shot_mode}.png"

    scrot -d "$delay" "$shot_mode_flag" "$save_as"
}

## some systems have gpg2 command instead of gpg, ideally i'll need to move gpg to guix itself
if command -v gpg2 >/dev/null
then
  gpg() { gpg2 "$@"; }
fi

if command -v git >/dev/null
then
  alias gi='git init'
  alias g='git'

  ## auto completion for aliases
  if [[ -n $OS ]] && [[ $OS = *Linux* ]]
  then
    git_completion_file="/usr/share/bash-completion/completions/git"
  else
    git_completion_file="/tmp/hopefully-non/existing-fil/e--and-directory/placeholder"
  fi

  if [[ -f "$git_completion_file" ]]
  then
    ## pollute the environment!!
    source "$git_completion_file"
    __git_complete g __git_main
  fi

  unset git_completion_file
fi
tattachws 2>/dev/null

## this var is the reason behind gnome icons missing 
unset GDK_PIXBUF_MODULE_FILE
