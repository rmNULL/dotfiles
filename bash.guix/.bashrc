# -*- sh -*-
# This file is sourced by all *interactive* bash shells on startup,
# including some apparently interactive shells such as scp and rcp
# that can't tolerate any output.  So make sure this doesn't display
# anything or bad things will happen !


# Test for an interactive shell.  There is no need to set anything
# past this point for scp and rcp, and it's important to refrain from
# outputting anything in those cases.
if [[ $- != *i* ]]
then
    # Shell is non-interactive.  Be done now!
    return
fi

# Don't execute commands when match fails
shopt -s failglob

# overwrite duplicate history


# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)

if ! command -v get-current-workspace-name >/dev/null
then
    get-current-workspace-name() { :; }
fi

PREV_ORG_PROMPT=""

gen_prompt() {
    local ec="$?"
    local branch="" user_prefix="" hints="" ORG_PROMPT=""
    history -a

    # kludge !!, as long as it works
    PS1=$(echo -n "$PS1" | sed 's/^\\e\[41;37;1m [0-9][0-9]* \\e\[0m\s*//')

    if command -v git >/dev/null 2>/dev/null
    then
        branch="$(git branch --show-current 2>/dev/null)"
        [[ -n "$branch" ]] &&
            branch="\e[47m\e[30m${branch:+ }${branch}${branch:+ }\e[0m"
    fi

    if [[ "$USER" != "rmnull" ]] || [[ -n "$SSH_CONNECTION" ]]
    then
        user_prefix="\e[31;1m\u\e[0m @ \e[33;1m\h\e[0m"
    else
        user_prefix=""
    fi

    if [[ -n $HOMEBREW_DEVELOPER ]]
    then
        hints+="\e[1;33m🍺\e[;0m"
    fi

    if [[ -n "$GUIX_ENVIRONMENT" ]]
    then
        local color="\e[38;5;166m" end_color="\e[0m"
        local guix_hint="${color}guix${end_color}"
        hints="[${guix_hint}]${hints:+ ${hints}}"
    fi

    ORG_PROMPT="${user_prefix}${user_prefix:+: }${branch:+${branch}}${branch:+ }${hints}\e[38;5;227m \w\e[0m\n∫ "

    if [[ -z $PREV_ORG_PROMPT ]]
    then
        PREV_ORG_PROMPT=$ORG_PROMPT
    fi

    # of course, this assumes other scripts don't make modifications to the
    # in the middle of PS1
    # dont overwrite prompt generated by other scripts
    # other scripts may have added additional info the prompt
    local pre_diff="" PREFIX=""
    pre_diff="$(( ${#PS1} - ${#PREV_ORG_PROMPT} ))"
    if [[ $pre_diff -gt 0 ]]
    then
        PREFIX="${PS1:0:${pre_diff}}"
    else
        PREFIX=""
    fi
    local SUFFIX="${PS1:$(( ${#PREFIX} + ${#PREV_ORG_PROMPT} ))}"

    PS1="${PREFIX}${ORG_PROMPT}${SUFFIX}"
    PREV_ORG_PROMPT=${ORG_PROMPT}

    if [[ $ec != "0" ]] ; then
        PS1="\e[41;37;1m $ec \e[0m ${PS1}"
    fi
}

eval "$(zoxide init bash)"

beet() {
    python3 -m beets "$@"
}

EOS_PIDS_DIR="${TMPDIR:-/tmp}"/pids/
mkdir -p "$EOS_PIDS_DIR"
mpdstats_pid_file="${EOS_PIDS_DIR}/beet.mpdstats"
if [[ -f $mpdstats_pid_file ]]
then
    pid=$(cat "$mpdstats_pid_file")
    kill -s 0 "$pid" 2>/dev/null || rm "$mpdstats_pid_file"
fi

if ! [[ -f "$mpdstats_pid_file" ]]
then
    if beet mpdstats 2>/dev/null >&2 &
    then
        pid="$!"
        echo -n "$pid" >"$mpdstats_pid_file"
        disown $pid
    else
        echo "failed to start beet mpdstats" >&2
    fi
fi
unset mpdstats_pid_file

if [[ -f ~/.config/mpd/pid  ]]; then
    pid=$(cat ~/.config/mpd/pid)
    kill -s 0 "$pid" 2>/dev/null || mpd
else
    mpd
fi > /dev/null 2>/dev/null


## conda init startup times are slow, and i don't use it often
conda_shell() {
    # >>> conda initialize >>>
    # !! Contents within this block are managed by 'conda init' !!
    __conda_setup="$('/home/rmnull/af/conda3/bin/conda' 'shell.bash' 'hook' 2> /dev/null)"
    if [ $? -eq 0 ]; then
        eval "$__conda_setup"
    else
        if [ -f "/home/rmnull/af/conda3/etc/profile.d/conda.sh" ]; then
            . "/home/rmnull/af/conda3/etc/profile.d/conda.sh"
        else
            export PATH="/home/rmnull/af/conda3/bin:$PATH"
        fi
    fi
    unset __conda_setup
    # <<< conda initialize <<<
}

if [[ -e "${HOME}/.fzf" ]]
then
    source "/home/rmnull/.fzf/shell/completion.bash"
    source "/home/rmnull/.fzf/shell/key-bindings.bash"
fi

if [[ -z "$PROMPT_COMMAND" ]]
then
    PROMPT_COMMAND=gen_prompt
else
    PROMPT_COMMAND="gen_prompt;${PROMPT_COMMAND}"
fi

if [[ -f ~/.bash_aliases ]]
then
    . ~/.bash_aliases
fi

emacs_daemon() {
    local pid;
    local server_name="$1";
    local LOG_FILE="/tmp/emacs_daemon_start.log"
    [[ -z "$server_name" ]] && return;
    pid=$(ps aux | grep -F "emacs --daemon=${name}" | grep -v grep | head -n 1)

    if [[ -z "$pid" ]]
    then
        emacs --daemon="${name}" >"$LOG_FILE" 2>&1 &
        pid=$!
        #echo -n "$pid" >"$pid_file"
        disown $pid
    fi
}

EMACS_DEFAULT_SERVER_NAME="$HOSTNAME"
export EMACS_DEFAULT_SERVER_NAME

for name in  "${EMACS_DEFAULT_SERVER_NAME}" # work media learn
do
    emacs_daemon "$name"
done
unset emacs_daemon

if false && command -v ssh-add >/dev/null && ! ssh-add -l >/dev/null 2>&1
then
    SSH_KEYS_DIR="${HOME}/.ssh"
    for key in pi.key
    do
        SSH_KEY="${SSH_KEYS_DIR}/${key}"
        [[ -e "${SSH_KEY}" ]] && ssh-add -k "$SSH_KEY"
    done
    unset SSH_KEY
    unset SSH_KEYS_DIR
fi


srec() {
    if [[ $# -gt 0 ]]
    then
        echo -e "WARN: doesn't accept any args. Ignoring all the arguments\n\n"
    fi

    local date_format=$(date --iso-8601=minutes)
    local save_dir="${HOME}/Videos/screenrecords"
    local out="${save_dir}/srec_${date_format}"
    local out_ll="${out}.mkv"
    local out_lo="${out}.webm"
    local display=${DISPLAY:-0.0}
    mkdir -p "$save_dir"
    ffmpeg -video_size 1920x1080 -framerate 30 -f x11grab -i "$display" -c:v libx264rgb -crf 0 -preset ultrafast "${out_ll}" \
        && ffmpeg -i "$out_ll" "$out_lo" && echo "saved to $out_lo"
}
rand_sym() {
    if [[ -z "$1" ]]
    then
        return;
    fi
    local symbols=$1;
    ## restrict to 7 bytes(2 ^ 56), as bash overflows at 2 ^ 63
    local randint=$(od --output-duplicates --address-radix=n --read-bytes=7 -t u8 </dev/urandom);
    local symbol_idx=$(( randint % ${#symbols} ))
    echo "${symbols:$symbol_idx:1}"
}

genpwd() {
    local dict_file="${HOME}/af/words-nouns.txt"
    [[ -e "$dict_file" ]] || return;
    local n_words=6;
    local min_word_len=3;
    local max_word_len=10;
    local separator=$(rand_sym '+-*/=_,.~><;:| ');
    local padding_symbol=$(rand_sym '~!@#$%^&*([{+=/|');
    local padding_start_symbol=$padding_symbol;
    local padding_end_symbol=$padding_symbol;
    [[ $padding_symbol = "(" ]] && padding_end_symbol=")";
    [[ $padding_symbol = "[" ]] && padding_end_symbol="]";
    [[ $padding_symbol = "{" ]] && padding_end_symbol="}";

    awk '/^[a-zA-Z0-9]+$/ && length($0) >= '"$min_word_len"' && length($0) <= '"$max_word_len" "$dict_file" \
        | shuf --repeat --random-source=/dev/urandom -n $n_words \
        | tr '\n' "$separator" \
        | tr '[:upper:]' '[:lower:]' \
        | sed -e 's/^\(.*\).$/\1/' \
        | xargs -I _ echo "$padding_start_symbol"_"$padding_end_symbol"
}

mupdf() {
    elog=$(command mupdf "$@" 2>&1)
    local mupdf_ec=$?

    if [[ "$mupdf_ec" != "0" ]] && grep -i '^error: needs a password' <<<"$elog"
    then
        local pass=$(zenity --title="PDF Password" --password)
        command mupdf -p "$pass" "$@"
        mupdf_ec=$?
    else
        echo -e "$elog" >&2
    fi

    ## honor MuPDF exit status
    return $mupdf_ec
}

scap() {
    local save_dir="${HOME}/Pictures/scaps/"
    mkdir -p "$save_dir"
    ## one of 'window' | 'select' | 'screen'
    local shot_mode="select" shot_mode_flag="-s"
    local delay=0
    local save_as="${save_dir}/#%s-${shot_mode}.png"

    scrot -d "$delay" "$shot_mode_flag" "$save_as"
}

## some systems have gpg2 command instead of gpg, ideally i'll need to move gpg to guix itself
if command -v gpg2 >/dev/null
then
  gpg() { gpg2 "$@"; }
fi

if command -v git >/dev/null
then
  alias gi='git init'
  alias g='git'

  ## auto completion for aliases
  if [[ -n $OS ]] && [[ $OS = *Linux* ]]
  then
    git_completion_file="/usr/share/bash-completion/completions/git"
  else
    git_completion_file="/tmp/hopefully-non/existing-fil/e--and-directory/placeholder"
  fi

  if [[ -f "$git_completion_file" ]]
  then
    ## pollute the environment!!
    source "$git_completion_file"
    __git_complete g __git_main
  fi

  unset git_completion_file
fi
#tattachws

unset GDK_PIXBUF_MODULE_FILE
